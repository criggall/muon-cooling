//	g4bltest.cc
/**	g4bltest is a command-line program to run multiple g4bl test files.
 *
 *	USAGE:
 *	g4bltest [-d] [--loop] [test file(s)]
 *		The optional -d sets Debug mode for all files (must be first).
 *		If no test files are given, test* is used from the test
 *			directory of the application.
 *		Note that matching directories are silently ignored.
 *		--loop makes it loop forever (counts are cumulative).
 *
 *	A test file consists of a series of commands, one per line, intermixed
 *	with data (non-command) lines. Every command starts with '=', and no
 *	non-command lines can start with that character.
 *
 *	Each test is run in a directory testname.dir, which is removed if
 *	the test succeeds. It is left if the test fails (so the files can
 *	be examined for the cause of the failure), and in debug mode.
 *
 *	Each test prints at most 1 line to stdout, depending on the TestResult:
 *		SUCCESS	prints the test name and title
 *		FAILURE prints the test name and the error message
 *		OMITTED prints the test name, title, and "- OMITTED" + reason
 *		OLDFORMAT prints nothing
 *	If any test is FAILURE, after running all tests g4bltest exits with
 *	exit-code 1 (failure); otherwise it exits with exit code 0 (success).
 *	OMITTED and OLDFORMAT tests do not contribute to the exit-code.
 *
 *	NOTE: the random number generators on Windows generate different
 *	sequences than on Linux or Darwin. So any tests that compare files
 *	that depend on random numbers will need a separate .good file for
 *	Windows (use the =platform command). For example, test009.
 *	This does not apply if =meanAndSigma is used with enough events,
 *	for example, test004 and test006.
 *
 *	Test file format:
 *
 *	The first line in the file must start with an '='; the remainder
 *	of the line is the title of the test. If the first line begins "#!"
 *	it is an OLDFORMAT test and is skipped without output.
 *
 *	Blank lines and lines beginning with '#' are ignored unless they are
 *	inside a =file command (in which case they are copied to the file).
 *
 *	Commands:
 *	=platform name1 name2 ...
 *		specifies the following commands are to be executed only
 *		on the named platform(s); if no names are given, all platforms.
 *		Applies up to the next =platform command.
 *		Platform names: WINDOWS LINUX DARWIN
 *	=file filename
 *		copies the following lines to filename, up to but not including
 *		the next command line. Copies blank lines and comments ("#...").
 *	=run program [arg1 arg2 ...]
 *		runs the program with the given arguments. The test fails if
 *		the program exits with non-zero exit-code. Arguments with 
 *		spaces must be quoted as the shell expects. stdout and stderr
 *		will be redirected to program.out (appending), unless some
 *		argument begins with '>' (i.e. output is already redirected).
 *		The command uses system(3) so PATH is searched, and internal
 *		bash/cmd commands can be used.
 *		NOTE: If program starts with "g4bl", it is run via absolute
 *		path from the same directory as this program (g4blDir/bin) to
 *		ensure it is from the same installation, regardless of PATH.
 *	=compare file1 file2 [c1 c2 ...]
 *		compares two ASCII files; the c1,c2... are tolerances for
 *		real numbers in columns 1, 2, ... If no column tolerances
 *		are given, then the files must compare exactly line-by-line.
 *		If a column tolerance is negative, that column is ignored
 *		(need not be numeric). With tolerances, files must consist of
 *		data in columns separated by spaces, or csv. Comments must
 *		appear in both files at the same lines, but their contents
 *		need not match.
 *	=fileContainedIn file1 file2
 *		succeeds if file1 is contained somewhere in file2.
 *	=meanAndSigma file output Ncols
 *		computes the mean and sigma for the first Ncols columns of 
 *		file, writing them to output on one line, doubling Ncols.
 *		=compare can then be used to verify they are within
 *		tolerance of the expected values (=compare to a good file
 *		generated by =file).
 *	=testbeam filename Xmin Xmax nX Ymin Ymax nY Z PDGid P
 *		generates a rectangular shaped beam into filename, with one
 *		track emitted parallel to the z axis at each grid point in x-y.
 *		Units are implicitly mm and MeV; t=0. Appends to the file.
 *		This is repeatable, exactly, on all platforms.
 *	=filelines file > 5
 *		succeeds if file has more than 5 lines. Can also use = and <.
 *		file must exist even with <.
 *	=exists filename
 *		succeeds if filename exists and is readable, fails if not.
 *	=grep [-v] 'regex' filename [out]
 *		succeeds if the regular expression 'regex' matches some line
 *		in the file. If -v is present, succeeds only if at least one
 *		line in the file does not match 'regex'. If out is omitted,
 *		grep.out is used; matching (not matching) lines are written
 *		to out.
 *	=omit reason
 *		omits this test. reason can be any string (printed).
 *	=require option1 [option2 ...]
 *		omits this test if any option is not present. Options are:
 *			mpi, root, gsl, fftw
 *	=echo message ...
 *		prints a message to stdout. Always succeeds. 
 *		As it can confuse the output, should be used only for debugging.
 *	=ignore error-message
 *		arranges to ignore an error message from the following
 *		command, as long as it contains the text of error-message.
 *		This command always succeeds, but the following command will
 *		succeed only if it issues an error message that matches.
 *		This is useful primarily for testing g4bltest itself,
 *		verifying that it generates correct error messages for 
 *		deliberately failing commands.
 *	=debug 
 *		sets Debug mode for this test, which prints each command and
 *		keeps the test directory. This is useful only for debugging.
 *		This applies to just this file from this point on; -d on the
 *		command-line applies to all files from their beginnings.
 **/

#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <stdio.h>
#include <math.h>
#include <ctype.h>

#ifdef WIN32
#include <windows.h>
#define mkdir(DIR,P) (!CreateDirectory(DIR,NULL))
#define chdir(DIR) (!SetCurrentDirectory(DIR))
#else
#include <unistd.h>
#include <glob.h>
#include <sys/stat.h>
#endif

#include <string>
#include <vector>
#include <map>

#include "Util.hh"	// getG4blDir()

// Translated from a program using Qt, hence these stand-in classes.

class String : public std::string {
public:
	String() : std::string() { }
	String(const char *p) : std::string(p) { }
	String(const String &r) : std::string(r) { }
	String(const std::string &r) : std::string(r) { }
	String(long n) : std::string()
		{ char tmp[64]; sprintf(tmp,"%ld",n); *this = String(tmp); }
	bool isNull() { return size() == 0; }
	bool isEmpty() { return size() == 0; }
	bool startsWith(String s) { return find(s) == 0; }
	bool endsWith(String s) { return rfind(s) == size()-s.size(); }
	bool contains(String s) { return find(s) != npos; }
	String trimmed() const {
		String ret = *this;
		while(ret.size() > 0 && isspace(ret[0]))
			ret.erase(0,1);
		while(ret.size() > 0 && isspace(ret[ret.size()-1]))
			ret.erase(ret.size()-1,1);
		return ret;
	}
	String simplified() const {
		String ret = trimmed();
		for(int i=0; i<ret.size(); ++i) {
			if(isspace(ret[i])) {
				ret.replace(i,1," ");
				while(i+1 < ret.size() && isspace(ret[i+1]))
					ret.erase(i+1,1);
			}
		}
		return ret;
	}
	String &replaceAll(String before, String after) {
		for(;;) {
			size_type i = find(before);
			if(i == npos) break;
			replace(i,before.size(),after);
		}
		return *this;
	}
	class StringList split(String s) const;
	int toInt(bool *ok=0) const {
		char *p; 
		int v=(int)strtol(c_str(),&p,0);
		if(ok != 0) *ok = (*p == '\0');
		return v;
	}
	double toDouble(bool *ok=0) const {
		char *p; 
		double v=strtod(c_str(),&p);
		if(ok != 0) *ok = (*p == '\0');
		return v;
	}
};

class StringList : public std::vector<String> {
public:
	StringList() : std::vector<String>() { }
	StringList &operator<<(const String &s) { push_back(s); return *this; }
	String join(String s) const {
		String ret;
		for(int i=0; i<size(); ++i) {
			if(ret.size() > 0) ret += s;
			ret += operator[](i);
		}
		return ret;
	}
	bool isEmpty() const { return size() == 0; }
	void removeFirst() { erase(begin()); }
	void removeLast() { pop_back(); }
};

StringList String::split(String s) const
{
	StringList ret;
	String::size_type i=0;
	while(i < size()) {
		String::size_type j = find(s,i);
		if(j != npos) {
			String t = substr(i,j-i);
			if(t.size() > 0) ret << t;
			i = j + s.size();
		} else {
			String t = substr(i);
			if(t.size() > 0) ret << t;
			break;
		}
	}
	return ret;
}

// local variables
static int Debug=0; // # files to debug; in code, use if(Debug > 0) ...
static String platformName = "???";
static String g4blDir;
static String currentDir;
static std::map<FILE*,String> unread;
static bool loop=false;

static String ignoreThis; // set by =ignore command

// local utility functions

// readLine() reads 1 line from its FILE and returns it as a String.
// Lines must be less than 4096 characters long.
// The end-of-line character(s) are removed. 
// Returns an empty String on EOF or error; returns " " if an empty line
// was read. Clears and returns unread[in] if it is not null.
String readLine(FILE *in)
{
	if(!unread[in].isNull()) {
		String ret = unread[in];
		unread[in] = String();
		return ret;
	}
	char buf[4096];
	char *p = fgets(buf,sizeof(buf),in);
	if(!p) return "";
	String ret(buf);
	int i = ret.find_first_of("\r\n");
	if(i != ret.npos) ret.erase(i);
	if(ret.size() == 0) return " ";
	return ret;
}

// listFilesInDir() returns a StringList of filenames in dir matching pattern.
// The returned strings begin "dir/" unless dir is empty.
StringList listFilesInDir(String dir, String pattern)
{
	StringList ret;
	String dirname = dir + "/";
	String search_path = dirname + pattern;
	if(dir.isEmpty()) {
		dirname = "";
		search_path = pattern;
	}
#ifdef WIN32
	WIN32_FIND_DATA fd; 
	HANDLE hFind = ::FindFirstFile(search_path.c_str(), &fd); 
	if(hFind != INVALID_HANDLE_VALUE) { 
		do { 
			if(!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
				ret.push_back(dirname+fd.cFileName);
		} while(::FindNextFile(hFind, &fd)); 
		::FindClose(hFind); 
	} 
#else
	glob_t g;
	g.gl_offs = 0;
	if(glob(search_path.c_str(),0,0,&g) == 0) {
		for(int i=0; i<g.gl_pathc; ++i) {
			struct stat sb;
			if(stat(g.gl_pathv[i], &sb) == 0 && S_ISREG(sb.st_mode))
				ret.push_back(g.gl_pathv[i]);
		}
	}
	globfree(&g);
#endif
	return ret;
}

// removedir() removes a directory and all its files and directories, 
// recursively. ERRORS ARE IGNORED.
void removeDir(String dir)
{
#ifdef WIN32
	StringList files = listFilesInDir(dir,"*");
	for(int i=0; i<files.size(); ++i) {
		if(DeleteFile(files[i].c_str()) == 0)
			removeDir(files[i]);
	}
	RemoveDirectory(dir.c_str());
#else
	StringList files = listFilesInDir(dir,"*");
	for(int i=0; i<files.size(); ++i) {
		if(unlink(files[i].c_str()) != 0)
			removeDir(files[i]);
	}
	rmdir(dir.c_str());
#endif
}

// basename() returns the last entry of a path. For a file this is the
// filename (without any directories).
String basename(const String s) {
	String retval = s;
	String::size_type i = retval.find_last_of("/\\");
	if(i != retval.npos && i < retval.size())
		retval.erase(0,i+1);
	return retval;
}


// Test functions

// testResult represents the result of a test.
enum TestResult {SUCCESS, FAILURE, OMITTED, OLDFORMAT};

// runTest returns the TestResult from running the test.
// In addition to any =echo commands, It prints at most 1 line:
//    (SUCCESS) test name and title
//    (FAILURE) test name and error message, with leading asterisks
//    (OMITTED) test name, title, and "- OMITTED: reason"
//    (OLDFORMAT) [no output]
static TestResult runTest(String filename);

// Commands return an error message, or a null String on success:
static String platform(StringList cmd, FILE *in);
static String file(StringList cmd, FILE *in);
static String run(StringList cmd);
static String compare(StringList cmd);
static String filelines(StringList cmd);
static String exists(StringList cmd);
static String grep(StringList cmd);
static String require(StringList cmd); // returns omitReason
static String echo(StringList cmd);
static String fileContainedIn(StringList cmd);
static String meanAndSigma(StringList cmd);
static String testbeam(StringList cmd);


// the main program

int main(int argc, char *argv[])
{
	if(argc > 1 && String(argv[1]) == "-d") {
		Debug = 999999999;
		--argc, ++argv;
	}

	if(argc > 1 && String(argv[1]) == "--loop") {
		loop = true;
		--argc, ++argv;
	}

	// get platformName, g4blDir, currentDir
	g4blDir = getG4blDir();
#ifdef WIN32
	platformName = "WINDOWS";
	char buf[1024];
	GetCurrentDirectory(sizeof(buf), buf);
	currentDir = buf;
#else
	char buf[1024];
	getcwd(buf,sizeof(buf));
	currentDir = buf;
#endif
#ifdef __linux__
	platformName = "LINUX";
#endif
#ifdef __APPLE__
	platformName = "DARWIN";
#endif

	printf("platformName=%s\n",platformName.c_str());
	printf("g4blDir=%s\n",g4blDir.c_str());
	printf("currentDir=%s\n",currentDir.c_str());

	// get list of test files to run
	StringList tests;
	for(int i=1; i<argc; ++i) {
		String s(argv[i]);
		if(s.startsWith(".") || s.endsWith(".dir")) continue;
		tests << s;
	}
	if(tests.isEmpty()) {
		tests = listFilesInDir(g4blDir+"/test","test*");
	}

	// run the tests
	int nFail = 0;
	int nSuccess = 0;
	int nOmit = 0;
	int nLoop=1;
	do {
		if(loop) printf("\ng4bltest: looping forever over the list of "
		    "tests (counts are cumulative). Start loop %d.\n",nLoop);
		for(int i=0; i<tests.size(); ++i) {
			switch(runTest(tests[i])) {
			case SUCCESS: ++nSuccess;	break;
			case FAILURE: ++nFail;		break;
			case OMITTED: ++nOmit;		break;
			case OLDFORMAT:			break;
			}
		}

		// print summary
		if(nFail == 0) {
	   		printf("All tests passed (%d total, %d omitted)\n",
	    				nSuccess+nOmit,nOmit);
		} else {
	   		printf("***g4bltest: %d tests failed out of %d tests "
			       "(%d omitted)\n", nFail,nFail+nSuccess+nOmit,
			       						nOmit);
	   		if(!loop) {
				printf("   Current directory: \"%s\"\n",
							currentDir.c_str());
	   			printf("   For each failing test a directory "
				       "has been created containing the "
				       "output(s).\n");
			}
		}
		++nLoop;
	} while(loop);

	return (nFail==0 ? 0 : 1);
}

TestResult runTest(String filename)
{
	TestResult retval=SUCCESS;
	String test = basename(filename);

	// open the test file
	FILE *in = fopen(filename.c_str(),"r");
	if(!in) {
		printf("%s: ***ERROR: Cannot read test file '%s'\n",
						test.c_str(),filename.c_str());
		return FAILURE;
	}
	unread.erase(in);

	if(Debug > 0) printf("\n==== start test %s\n",test.c_str());

	// read the test title
	String title = readLine(in); // (<CRLF> removed)
	if(title[0] != '=') {
		if(title.startsWith("#!")) {
			fclose(in);
			return OLDFORMAT;
		}
		printf("%s: ***ERROR: Invalid test file\n",test.c_str());
		fclose(in);
		return FAILURE;
	}
	title = title.substr(1);
	
	// create a directory for the test and cd to it
	removeDir(test+".dir");            // don't care if this fails
	mkdir((test+".dir").c_str(),0755); // if this fails, so will the next
	if(chdir((test+".dir").c_str()) != 0) {
		printf("%s: ***ERROR: cannot cd to '%s'\n",
		    		test.c_str(),(test+".dir").c_str());
		fclose(in);
		return FAILURE;
	}

	// loop over commands in the test file
	String errorMsg;
	ignoreThis = String();
	String ignoreNext;
	String omitReason;
	while(errorMsg.isNull()) {
		String line = readLine(in);
		if(line.isNull()) break;
		if(Debug > 0) printf("==== line='%s'\n",line.c_str());
		StringList cmd = line.simplified().split(" ");
		if(cmd.isEmpty() || cmd[0].startsWith("#"))
			continue;
		if(cmd[0] == "=platform") 
			errorMsg = platform(cmd,in);
		else if(cmd[0] == "=file") 
			errorMsg = file(cmd,in);
		else if(cmd[0] == "=run") 
			errorMsg = run(cmd);
		else if(cmd[0] == "=compare") 
			errorMsg = compare(cmd);
		else if(cmd[0] == "=filelines") 
			errorMsg = filelines(cmd);
		else if(cmd[0] == "=exists") 
			errorMsg = exists(cmd);
		else if(cmd[0] == "=grep") 
			errorMsg = grep(cmd);
		else if(cmd[0] == "=omit") 
			{ errorMsg = ""; retval = OMITTED; cmd.removeFirst();
			  omitReason = cmd.join(" "); break; }
		else if(cmd[0] == "=require") 
			{ omitReason = require(cmd);
			  if(!omitReason.isNull()) {
			    retval = OMITTED;
			    break;
			  }
			}
		else if(cmd[0] == "=echo") 
			errorMsg = echo(cmd);
		else if(cmd[0] == "=fileContainedIn") 
			errorMsg = fileContainedIn(cmd);
		else if(cmd[0] == "=meanAndSigma") 
			errorMsg = meanAndSigma(cmd);
		else if(cmd[0] == "=testbeam") 
			errorMsg = testbeam(cmd);
		else if(cmd[0] == "=ignore") 
			ignoreNext = line, ignoreNext.erase(0,8);
		else if(cmd[0] == "=debug") 
			++Debug;
		else
			errorMsg = "Unknown test command '"+cmd[0]+"'";
		if(!ignoreThis.isNull()) {
			if(errorMsg.contains(ignoreThis))
				errorMsg = String();
			else if(errorMsg.isNull())
				errorMsg = "Command should have failed";
		}
		ignoreThis = ignoreNext;
		ignoreNext = String();
		if(Debug > 0 && !errorMsg.isNull())
			printf("***errorMsg=%s\n",errorMsg.c_str());
	}
	if(Debug > 0) printf("==== end test %s\n",test.c_str());
	if(errorMsg.startsWith("OMITTED")) {
		omitReason = errorMsg.substr(8);
		errorMsg = String();
		retval = OMITTED;
	}
	if(!errorMsg.isNull()) {
		FILE *out = fopen("ErrorMessage","w");
		fputs(errorMsg.c_str(),out);
		fputs("\n",out);
		fclose(out);
		retval = FAILURE;
	}

	// clean up
	chdir("..");
	fclose(in);

	// print 1-line summary
	switch(retval) {
	case FAILURE:
	    assert(!errorMsg.isNull());
	    printf("%s: ***ERROR: %s\n",test.c_str(),errorMsg.c_str());
	    break;
	case SUCCESS:
	    assert(errorMsg.isNull());
	    printf("%s: %s\n",test.c_str(),title.c_str());
	    break;
	case OMITTED:
	    assert(errorMsg.isNull());
	    printf("%s: %s - OMITTED: %s\n",test.c_str(),title.c_str(),
	    						omitReason.c_str());
	    break;
	case OLDFORMAT:
	    break;
	}

	if(retval != FAILURE && Debug <= 0) removeDir(test+".dir");
	--Debug;
	fflush(stdout);
	return retval;
}

String platform(StringList cmd, FILE *in)
{
	for(int i=1; i<cmd.size(); ++i) {
		if(cmd[i] != "WINDOWS" && cmd[i] != "LINUX" &&
		   cmd[i] != "DARWIN")
			return "=platform Invalid platform '"+cmd[i]+"'";
	}

	if(cmd.size() < 2) return String(); // all platforms, execute commands

	for(int i=1; i<cmd.size(); ++i)
		if(cmd[i] == platformName) return String(); // execute commands

	// read and discard input until next "=platform"
	for(;;) {
		String line = readLine(in);
		if(line.isNull()) return String();
		if(line.startsWith("=platform")) {
			unread[in] = line;
			break;
		}
	}
	return String();
}

String file(StringList cmd, FILE *in)
{
	FILE *out = fopen(cmd[1].c_str(),"w");
	if(!out) {
	    String s = "Cannot write file '" + cmd[1] + "'";
	    return s;
	}
	for(;;) {
		String line = readLine(in);
		if(line.isNull() || line.startsWith("=")) {
			unread[in] = line;
			break;
		}
		fputs((line+"\n").c_str(),out);
	}
	fclose(out);
	return String();
}

String run(StringList cmd)
{
	cmd.removeFirst(); // remove "=run"

	String outfile = basename(cmd[0]);

	// make sure g4bl* programs are from this installation
	// (g4blDir may have spaces, need "")
	if(cmd[0].startsWith("g4bl"))
		cmd[0] = '"' + g4blDir + "/bin/" + cmd[0] + '"';

	// check for redirection on the command-line
	bool redirect=true;
	for(int i=0; i<cmd.size(); ++i) {
		if(cmd[i].startsWith(">")) redirect = false;
	}

	// get the command string
	String s = cmd.join(" ");
	if(redirect) {
		outfile += ".out";
		s += " >>" + outfile + " 2>&1";
	}

	// run the command
	if(Debug > 0) printf("command='%s'\n",s.c_str());
	int ret = system(s.c_str()); // blocks until command exits
	if(ret != 0)
		return "=run '" + s + "' failed";

	return String();
}

String compare(StringList cmd)
{
	String retval;
	if(cmd.size() < 3) return "=compare Invalid =compare command";

	FILE *f1 = fopen(cmd[1].c_str(),"r");
	if(!f1) {
		return "=compare Cannot read file '" + cmd[1] + "'";
	}
	unread.erase(f1);

	FILE *f2 = fopen(cmd[2].c_str(),"r");
	if(!f2) {
		fclose(f1);
		return "=compare Cannot read file '" + cmd[2] + "'";
	}
	unread.erase(f2);

	if(cmd.size() == 3) {
		// file compare (not columns or csv)
		int linenum=0;
		for(;;) {
			String line1 = readLine(f1);
			String line2 = readLine(f2);
			if(line1.isNull() && line2.isNull()) break;
			if(line1.isNull() || line2.isNull()) {
				retval = "=compare Files '"+cmd[1]+"' and '"+
					cmd[2]+"' have different lengths";
				break;
			}
			++linenum;
			if(line1 != line2) {
				retval = "=compare Files '"+cmd[1]+"' and '"+
					cmd[2]+"' differ at line "+
					String(linenum);
				break;
			}
		}
	} else {
		// file compare with column tolerances
		std::vector<double> tolerance;
		bool ok;
		for(int i=3; i<cmd.size(); ++i) {
			tolerance.push_back(cmd[i].toDouble(&ok));
			if(!ok) break;
		}
		int linenum=0;
		if(ok) {
		    for(;;) {
			String line1 = readLine(f1);
			String line2 = readLine(f2);
			if(line1.isNull() && line2.isNull()) break;
			if(line1.isNull() || line2.isNull()) {
				retval = "=compare Files '"+cmd[1]+"' and '"+
					cmd[2]+"' have different lengths";
				break;
			}
			++linenum;
			line1.replaceAll(","," ");
			line2.replaceAll(","," ");
			StringList list1 = line1.simplified().split(" ");
			StringList list2 = line2.simplified().split(" ");
			if((list1.isEmpty() || list1[0].startsWith("#")) &&
			   (list2.isEmpty() || list2[0].startsWith("#")))
				continue;
			if((list1.isEmpty() || list1[0].startsWith("#")) ||
			   (list2.isEmpty() || list2[0].startsWith("#"))) {
				retval = "=compare Files '"+cmd[1]+"' and '"+
					cmd[2]+"' comment mismatch, line "+
					String(linenum);
				if(Debug > 0) printf("%s\n%s\n%s\n",
					retval.c_str(),
				    	line1.c_str(),line2.c_str());
				break;
			}
			if(list1.size() < tolerance.size() ||
					list2.size() < tolerance.size()) {
				retval = "=compare File '"+cmd[1]+"' and/or '"+
					cmd[2]+"' has too few columns, line "+
					String(linenum);
				if(Debug > 0) printf("%s\n%s\n%s\n",
					retval.c_str(),
				    	line1.c_str(),line2.c_str());
				break;
			}
			for(int i=0; i<tolerance.size(); ++i) {
				if(tolerance[i] < 0.0) continue;
				bool ok1, ok2;
				double v1 = list1[i].toDouble(&ok1);
				double v2 = list2[i].toDouble(&ok2);
				if(!ok1 || !ok2) {
				   retval = "=compare File '"+cmd[1]+
				   	"' and/or '"+cmd[2]+
				   	"' has invalid data on line "+
					String(linenum)+", column "+String(i+1);
				    if(Debug > 0) printf("%s\n%s\n%s\n",
						retval.c_str(),
				    		line1.c_str(),line2.c_str());
				    break;
				}
				if(fabs(v1-v2) > tolerance[i]) {
				   retval = "=compare Files '"+cmd[1]+"' and '"+
				   	cmd[2]+"' differ at line "+
					String(linenum)+", column "+String(i+1);
				    if(Debug > 0) printf("%s\n%s\n%s\n",
						retval.c_str(),
				    		line1.c_str(),line2.c_str());
				    break;
				}
			}
			if(!retval.isNull()) break;
		    }
		} else {
			retval = "=compare Invalid column tolerance";
		}
	}

	fclose(f1);
	fclose(f2);
	return retval;
}

String filelines(StringList cmd)
{
	if(cmd.size() < 4) return "=filelines invalid command";
	String compare = cmd[2];
	int value = cmd[3].toInt();

	FILE *p = fopen(cmd[1].c_str(),"r");
	if(!p)
		return "=filelines File does not exist ' " + cmd[1] + "'";

	int n=0;
	for(;;) {
		if(readLine(p).isNull()) break;
		++n;
	}
	fclose(p);

	if(compare == "=" && n != value)
	    return "file '"+cmd[1]+"' does not have "+String(value)+" lines";
	if(compare == ">" && n <= value)
	    return "file '"+cmd[1]+"' does not have more than "+String(value)+
	    							" lines";
	if(compare == "<" && n >= value)
	    return "file '"+cmd[1]+"' does not have less than "+String(value)+
	    							" lines";

	return String();
}

String exists(StringList cmd)
{
	if(cmd.size() != 2) return "=exists invalid command";
	FILE *p = fopen(cmd[1].c_str(),"r");
	if(!p)
		return "=exists File does not exist ' " + cmd[1] + "'";
	fclose(p);
	return String();
}

String grep(StringList cmd)
{
	if(cmd.size() < 3) return "=grep invalid command";
	cmd.removeFirst(); // remove =grep
	bool v(false);
	if(cmd[0] == "-v") {
		v = true;
		cmd.removeFirst();
	}
	// handle optionally-quoted pattern
	String pattern(cmd[0]);
	if(pattern.startsWith("\"") || pattern.startsWith("'")) {
		char q[2] = {0,0};
		q[0] = pattern[0];
		while(!pattern.endsWith(q)) {
			cmd.removeFirst();
			if(cmd.size() < 2) return "=grep invalid command";
			pattern += " " + cmd[0];
		}
	}
	// now pattern either contains no spaces, or is quoted
	// now cmd[0] is the end of the pattern
	if(cmd.size() < 2) return "=grep invalid command";
	String infile = cmd[1];
	String outfile = (cmd.size()>2 ? cmd[2] : "grep.out");
#ifdef WIN32
	String s = "findstr /r ";
	if(v) s += "/v ";
	// Windows can only use " for quotes
	for(;;) {
		size_t i = pattern.find_first_of("'");
		if(i == std::string::npos) break;
		pattern.replace(i,1,"\"");
	}
	s += pattern + " " + infile + " >" + outfile;
#else
	String s = "grep ";
	if(v) s += "-v ";
	s += pattern + " " + infile + " >" + outfile;
#endif
	// run the command in s
	if(Debug > 0) printf("=grep is running '%s'\n",s.c_str());
	int ret = system(s.c_str()); // blocks until command exits
	if(ret != 0)
		return "=" + s + " -- command failed";
	return String();
}

// require() returns omitReason, not errorMsg.
String require(StringList cmd)
{
	for(unsigned i=1; i<cmd.size(); ++i) {
		if(cmd[i] == "mpi") {
#ifndef G4BL_MPI
			return "MPI not configured";
#else
			continue;
#endif
		} else if(cmd[i] == "root")  {
#ifndef G4BL_ROOT
			return "Root not configured";
#else
			continue;
#endif
		} else if(cmd[i] == "gsl")  {
#ifndef G4BL_GSL
			return "GSL not configured";
#else
			continue;
#endif
		} else if(cmd[i] == "fftw")  {
#ifndef G4BL_FFTW
			return "FFTW not configured";
#else
			continue;
#endif
		}
	}
	return String();
}

String echo(StringList cmd)
{
	cmd.removeFirst(); // remove "=echo"
	printf("%s\n",cmd.join(" ").c_str());
	return String();
}

String fileContainedIn(StringList cmd)
{
	String retval;
	if(cmd.size() < 3) return "=fileContainedIn invalid command";

	FILE *f1 = fopen(cmd[1].c_str(),"r");
	if(!f1) {
		return "=fileContainedIn Cannot read file '" + cmd[1] + "'";
	}
	unread.erase(f1);

	FILE *f2 = fopen(cmd[2].c_str(),"r");
	if(!f2) {
		return "=fileContainedIn Cannot read file '" + cmd[2] + "'";
	}
	unread.erase(f2);

	// find the first line
	String line1 = readLine(f1);
	while(retval.isNull()) {
		String line2 = readLine(f2);
		if(line2.isNull())
			retval = "=fileContainedIn file compare error";
		if(line1 == line2) break;
	}

	// compare remaining lines
	while(retval.isNull()) {
		line1 = readLine(f1);
		if(line1.isNull()) break;
		String line2 = readLine(f2);
		if(line2.isNull() || line1 != line2)
			return "=fileContainedIn file compare error";
	}

	fclose(f1);
	fclose(f2);
	return retval;
}

String meanAndSigma(StringList cmd)
{
	String retval;

	// =meanAndSigma input output ncols
	if(cmd.size() < 4) return "=meanAndSigma too few arguments";

	FILE *in = fopen(cmd[1].c_str(),"r");
	if(!in) {
		return "=meanAndSigma Cannot read file '" + cmd[1] + "'";
	}
	unread.erase(in);

	FILE *out = fopen(cmd[2].c_str(),"w");
	if(!out) {
		fclose(in);
		return "=meanAndSigma Cannot write file '" + cmd[2] + "'";
	}

	int ncols = cmd[3].toInt();
	if(ncols < 1) {
		fclose(in);
		fclose(out);
		return "=meanAndSigma Invalid number of columns";
	}
	std::vector<double> sum, sum2;
	for(int i=0; i<ncols; ++i) {
		sum.push_back(0.0);
		sum2.push_back(0.0);
	}

	// read file
	int nentries=0;
	int linenum=0;
	for(;;) {
		String line = readLine(in);
		if(line.isNull()) break;
		++linenum;
		line.replaceAll(","," ");
		StringList cols = line.simplified().split(" ");
		if(cols.isEmpty() || cols[0].startsWith("#")) continue;
		if(cols.size() < ncols) {
			fclose(in);
			fclose(out);
			return "=meanAndSigma File '"+cmd[1]+
			       "' has too few columns in line "+String(linenum);
		}
		for(int i=0; i<ncols; ++i) {
			bool ok;
			double v = cols[i].toDouble(&ok);
			if(!ok) {
			    fclose(in);
			    fclose(out);
			    return "=meanAndSigma File '"+cmd[1]+
			       "' has invalid data in line "+String(linenum);
			}
			sum[i] += v;
			sum2[i] += v*v;
		}
		++nentries;
	}

	for(int i=0; i<ncols; ++i) {
		double mean=0.0, sigma=0.0;
		if(nentries > 1) {
			 mean = sum[i]/nentries;
			 sigma = sqrt(sum2[i]/nentries - mean*mean);
		}
		fprintf(out,"%g %g ",mean,sigma);
	}
	fprintf(out,"\n");

	fclose(in);
	fclose(out);
	return retval;
}

String testbeam(StringList cmd)
{
	// =testbeam filename Xmin Xmax nX Ymin Ymax nY Z PDGid P
	if(cmd.size() < 11) return "=testbeam too few arguments";
	char *p;
	String filename = cmd[1];
	double Xmin = strtod(cmd[2].c_str(),&p);
	if(*p != '\0') return "=testbeam Syntax error in Xmin";
	double Xmax = strtod(cmd[3].c_str(),&p);
	if(*p != '\0') return "=testbeam Syntax error in Xmax";
	int nX = strtol(cmd[4].c_str(),&p,0);
	if(*p != '\0') return "=testbeam Syntax error in nX";
	double Ymin = strtod(cmd[5].c_str(),&p);
	if(*p != '\0') return "=testbeam Syntax error in Ymin";
	double Ymax = strtod(cmd[6].c_str(),&p);
	if(*p != '\0') return "=testbeam Syntax error in Ymax";
	int nY = strtol(cmd[7].c_str(),&p,0);
	if(*p != '\0') return "=testbeam Syntax error in nY";
	double Z = strtod(cmd[8].c_str(),&p);
	if(*p != '\0') return "=testbeam Syntax error in Z";
	long PDGid = strtol(cmd[9].c_str(),&p,0);
	if(*p != '\0') return "=testbeam Syntax error in PDGid";
	double P = strtod(cmd[10].c_str(),&p);
	if(*p != '\0') return "=testbeam Syntax error in P";
	if(nX < 2 || nY < 2) return "=testbeam Syntax error, invalid nX or nY";

	FILE *out = fopen(filename.c_str(),"a");
	if(!out) {
		String s("Cannot write file ");
		return s + filename.c_str();
	}
	fprintf(out,"#BLTrackFile %s\n",cmd.join(" ").c_str());
	fprintf(out,"#x y z Px Py Pz t PDGid EventID TrackID ParentID Weight\n");

	double dX = (Xmax-Xmin)/(nX-1);
	double dY = (Ymax-Ymin)/(nY-1);
	int EventID=1;
	for(int i=0; i<nX; ++i) {
		double x = Xmin + i*dX;
		for(int j=0; j<nY; ++j) {
			double y = Ymin + j*dY;
			fprintf(out,"%g %g %g 0 0 %g 0 %ld %d 1 0 1\n",
				x,y,Z,P,PDGid,EventID);
			++EventID;
		}
	}

	fclose(out);
	return String();
}

